# Baby Billing **(o˘◡˘o)**  

## Структура:
Приложение состоит из трех микросервисов, которые эмулируют генерацию **_CDR(Call Data Record)_** и обработку сгенерированных 
данных, для последующей тарификации.
## 1. **_CDR (Call Data Record)_** генератор
Микросервис генерирует параллельно **_CDR_** файлы, которые с помощью **_kafka_** отправляются в **_BRT(Billing Real Time)_** микросервис 
для авторизации абонентов. Генерация происходит итеративно по месяцу, в зависимости от количества потоков, на столько 
частей делится месяц и передается каждая часть в отдельный поток для генерации в этот период звонков. После собираются 
все в один список и сортируется по времени окончания звонков. 

Задача состояла в параллельной генерации, поэтому чтобы сгенерированные данные были правдоподобными, использовал синхронизатор
**_Phaser_** чтобы каждый поток посчитал свою часть из выделенного месяца. На этой идее было построено управление генерацией.
В [**_Swagger_**](http://localhost:8765/webjars/swagger-ui/index.html) есть отдельный тег **_CDR_**, в котором находятся следующие 
запросы: 

1. **_/api/start_** --- Запуск генератора CDR. Если просто запустить, то будет сгенерированы звонки за весь тарифицируемый период.
2. **_/api/register_** --- Ранее мною было сказано про синхронизаторы, так вот **_register_** добавляет стоп-поинт. Сколько стоп-поинтов
добавить, столько и нужно будет вызвать **_/api/iterate_** для выполнения одной итерации(один месяц). 
3. **_/api/deregister_** --- Удалить один стоп-поинт.
4. **_/api/iterate_** --- Выполнить итерацию.

Идея в том, что можно управлять генерацией CDR для разных целей, также чтобы можно было поведение клиентов за месяц или 
сразу за весь период. А также можно поставить стоп-поинт, запустить эмуляцию и выполнить запросы в CRM (добавить нового 
абонента, пополнить счет или изменить тариф).
### Гайд по использованию стоп-поинтов :)
1. Сначала лучше поставить стоп-поинт(**_/api/register_**), потому что генерация выполняется довольно быстро.
2. Затем запустить эмуляцию(**_/api/start_**). Запустится генерация для первого месяца.
3. Дальше можно либо запускать для каждого месяца (**_/api/iterate_**) или если не хотите больше работать в итеративном режиме, то
просто вызовите(**_/api/deregister_**) пока не будет ноль стоп-поинтов и генерация продолжится до конца тарифицируемого периода.
4. После того как запускается 12-ый месяц, нужно еще раз тыкнуть (**_/api/iterate_**) ;)

## 2. **_BRT (Billing Real Time)_**
Микросервис принимает с помощью кафки закодированные **_base64_** файлы, которые парсит и проводит авторизацию абонента, если 
абонент не является абонентом Ромашки, то эта запись из файла отбрасывается (также отбрасываются те записи, которые просто 
некорректны). 

Перед тем, как отправить запрос в **_HRS(High performance rating server)_**, проверяет запись на пересечение границы 
месяца. Если наступил новый месяц, то выполняются пополнение балансов (разные суммы в зависимости от тарифа). Затем 
отправляется запрос в **_HRS_**, чтобы получить данные о тех абонентах, кто пользуется месячным тарифом. Возвращается список
абонентов с суммой, которую должны заплатить, так как информация о тарифах хранится в **_HRS_**. 

В **_BRT_** есть кеш, который хранит тарифы, но без всех деталей. После выполняется смена тарифов у нескольких абонентов. Информация 
о смене тарифов передается в кеш **_HRS_**, чтобы в **_HRS_** велись актуальные вычисления. Когда проверка на новый месяц прошла, отправляется 
запрос в **_HRS_**, чтобы высчитать сколько должен заплатить абонент за его звонок. По возвращению происходит списание со счета.

CRM контроллер находится в BRT сервисе:
1.  **_/api/subscriber/{msisdn}/pay:_**

    Пополнение счета абонента, для того чтобы отправить запрос, нужно авторизоваться со своим номером:
    
        login: 79500493300

    Сумма пополнения с минимальным шагом 0.1. Поэтому минимально можно пополнить счет на 0.1

2.  **_/api/subscriber/{msisdn}/changeTariff_**:

    Смена тарифа, проводится менеджером, необходимо авторизоваться:

        login:    admin
        password: admin

3.  **_/api/subscriber/save_**:
    Добавление нового абонента, также проводится менеджером, поэтому так же требуется авторизоваться

        login:    admin
        password: admin
    Номер не должен быть зарегистрирован на кого-то. По умолчанию новый абонент добавляется с 100 у.е. на счету

## 3. **_HRS_**
В данном микросервисе проходят все вычисления по тарифам. В нем хранится таблица с тарифами, кеш с клиентами. В зависимости
от типа звонка и кому звонок происходил, вычисляется сколько нужно заплатить. Или если звонок был совершен абонентом с 
помесячным тарифом, то в кеше будет сохраняться количество оставшихся минут на этот месяц. Ранее было описано о том, что
в BRT отправляется запрос при новом месяце и обращается в кеш, чтобы узнать информацию о тарифе.

## **_Api Gateway_**
Написан шлюз, чтобы можно было обращаться по одному порту ко всем микросервисам и **_api_**. С использованием **_eureka server_**, порты
генерируются автоматически, поэтому не нужно хранить об этом информацию. На шлюзе хранится Swagger, с помощью которого 
можно обращаться к нескольким **_api_**. 
    
Если будет желание обратиться к микросервисам через например Postman, нужно будет отправлять запросы на: 
http://localhost:8765/<название_микросервиса>/api/** . По неведомым мне причинам роуты на шлюзе не 
редиректят на нужную нам апишку без ее названия :(            

## Ссылки:
### 1. База данных **_CDR_**:
## [**_h2-console_**](http://localhost:8765/cdr/h2-console)

        login:    sa
        password: password

        jdbc url: jdbc:h2:file:~/switch-emulator;AUTO_SERVER=true
### 2. База данных **_BRT_**:

Я к postgres базам подключался через докер контейнеры.

        sudo docker exec -it brt-postgres-db psql -U postgres

        \c brt-db

        Пример:
        SELECT * FROM client;

### 3. База данных **_HRS_**:

        sudo docker exec -it hrs-postgres-db psql -U postgres

        \c hrs-db

        Пример:
        SELECT * FROM tariff;
### 4. [**_Swagger_**](http://localhost:8765/webjars/swagger-ui/index.html)

---

## Запуск приложения: 
Для запуска в докере и без были сделаны профили для запуска локально и в докере.
### 1. Полностью все в докере

    sudo docker compose -f docker-compose.yml up

Когда поднимутся все контейнеры, можно сразу работать и запустить Swagger.

### 2. БД и кафка в докере

    sudo docker compose -f docker-compose-wms.yml up

После запуска всех контейнеров, первым необходимо запустить первым Eureka server. Необходимо дождаться его запуска и тогда
можно запускать все микросервисы(**_cdr, brt, hrs_**). По окончании запуска микросервисов, стартуем **_api-gateway_**.
Теперь так же можем работать в [Swagger'e](http://localhost:8765/swagger-ui.html).

## Абоненты оператора Ромашки, которые уже в базе данных:

    79500493300, 11, 100.
    79432877546, 12, 100.
    79110824307, 12, 100.
    79729044156, 11, 100.
    79476869787, 11, 100.
    79345493670, 11, 100.
    79433478645, 12, 100.
    79180643455, 12, 100.
    79743042657, 11, 100.
    79474839234, 11, 100.
